{"ast":null,"code":"function $(element, tagName) {\n  return Array.from(element.getElementsByTagName(tagName));\n}\nfunction normalizeId(id) {\n  return id[0] === \"#\" ? id : `#${id}`;\n}\nfunction $ns(element, tagName, ns) {\n  return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n/**\n * get the content of a text node, if any\n */\nfunction nodeVal(node) {\n  node?.normalize();\n  return node && node.textContent || \"\";\n}\n/**\n * Get one Y child of X, if any, otherwise null\n */\nfunction get1(node, tagName, callback) {\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) callback(result);\n  return result;\n}\nfunction get(node, tagName, callback) {\n  const properties = {};\n  if (!node) return properties;\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) {\n    return callback(result, properties);\n  }\n  return properties;\n}\nfunction val1(node, tagName, callback) {\n  const val = nodeVal(get1(node, tagName));\n  if (val && callback) return callback(val) || {};\n  return {};\n}\nfunction $num(node, tagName, callback) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (val && callback) return callback(val) || {};\n  return {};\n}\nfunction num1(node, tagName, callback) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (callback) callback(val);\n  return val;\n}\nfunction getMulti(node, propertyNames) {\n  const properties = {};\n  for (const property of propertyNames) {\n    val1(node, property, val => {\n      properties[property] = val;\n    });\n  }\n  return properties;\n}\nfunction isElement(node) {\n  return node?.nodeType === 1;\n}\nfunction getLineStyle(node) {\n  return get(node, \"line\", lineStyle => {\n    const val = Object.assign({}, val1(lineStyle, \"color\", color => {\n      return {\n        stroke: `#${color}`\n      };\n    }), $num(lineStyle, \"opacity\", opacity => {\n      return {\n        \"stroke-opacity\": opacity\n      };\n    }), $num(lineStyle, \"width\", width => {\n      // GPX width is in mm, convert to px with 96 px per inch\n      return {\n        \"stroke-width\": width * 96 / 25.4\n      };\n    }));\n    return val;\n  });\n}\nfunction getExtensions(node) {\n  let values = [];\n  if (node === null) return values;\n  for (const child of Array.from(node.childNodes)) {\n    if (!isElement(child)) continue;\n    const name = abbreviateName(child.nodeName);\n    if (name === \"gpxtpx:TrackPointExtension\") {\n      // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n      values = values.concat(getExtensions(child));\n    } else {\n      // push custom extension (eg. \"power\")\n      const val = nodeVal(child);\n      values.push([name, parseNumeric(val)]);\n    }\n  }\n  return values;\n}\nfunction abbreviateName(name) {\n  return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\nfunction parseNumeric(val) {\n  const num = parseFloat(val);\n  return isNaN(num) ? val : num;\n}\nfunction coordPair$1(node) {\n  const ll = [parseFloat(node.getAttribute(\"lon\") || \"\"), parseFloat(node.getAttribute(\"lat\") || \"\")];\n  if (isNaN(ll[0]) || isNaN(ll[1])) {\n    return null;\n  }\n  num1(node, \"ele\", val => {\n    ll.push(val);\n  });\n  const time = get1(node, \"time\");\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(node, \"extensions\"))\n  };\n}\nfunction extractProperties(node) {\n  const properties = getMulti(node, [\"name\", \"cmt\", \"desc\", \"type\", \"time\", \"keywords\"]);\n  const extensions = Array.from(node.getElementsByTagNameNS(\"http://www.garmin.com/xmlschemas/GpxExtensions/v3\", \"*\"));\n  for (const child of extensions) {\n    if (child.parentNode?.parentNode === node) {\n      properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child);\n    }\n  }\n  const links = $(node, \"link\");\n  if (links.length) {\n    properties.links = links.map(link => Object.assign({\n      href: link.getAttribute(\"href\")\n    }, getMulti(link, [\"text\", \"type\"])));\n  }\n  return properties;\n}\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints$1(node, pointname) {\n  const pts = $(node, pointname);\n  const line = [];\n  const times = [];\n  const extendedValues = {};\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair$1(pts[i]);\n    if (!c) {\n      continue;\n    }\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (const [name, val] of c.extendedValues) {\n      const plural = name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n  if (line.length < 2) return; // Invalid line in GeoJSON\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues\n  };\n}\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(node) {\n  const line = getPoints$1(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign({\n      _gpxType: \"rte\"\n    }, extractProperties(node), getLineStyle(get1(node, \"extensions\"))),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line\n    }\n  };\n}\nfunction getTrack(node) {\n  const segments = $(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n  for (const segment of segments) {\n    const line = getPoints$1(segment, \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n  if (extractedLines.length === 0) return null;\n  const multi = extractedLines.length > 1;\n  const properties = Object.assign({\n    _gpxType: \"trk\"\n  }, extractProperties(node), getLineStyle(get1(node, \"extensions\")), times.length ? {\n    coordinateProperties: {\n      times: multi ? times : times[0]\n    }\n  } : {});\n  for (const line of extractedLines) {\n    track.push(line.line);\n    if (!properties.coordinateProperties) {\n      properties.coordinateProperties = {};\n    }\n    const props = properties.coordinateProperties;\n    const entries = Object.entries(line.extendedValues);\n    for (let i = 0; i < entries.length; i++) {\n      const [name, val] = entries[i];\n      if (multi) {\n        if (!props[name]) {\n          props[name] = extractedLines.map(line => new Array(line.line.length).fill(null));\n        }\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi ? {\n      type: \"MultiLineString\",\n      coordinates: track\n    } : {\n      type: \"LineString\",\n      coordinates: track[0]\n    }\n  };\n}\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(node) {\n  const properties = Object.assign(extractProperties(node), getMulti(node, [\"sym\"]));\n  const pair = coordPair$1(node);\n  if (!pair) return null;\n  return {\n    type: \"Feature\",\n    properties,\n    geometry: {\n      type: \"Point\",\n      coordinates: pair.coordinates\n    }\n  };\n}\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nfunction* gpxGen(node) {\n  for (const track of $(node, \"trk\")) {\n    const feature = getTrack(track);\n    if (feature) yield feature;\n  }\n  for (const route of $(node, \"rte\")) {\n    const feature = getRoute(route);\n    if (feature) yield feature;\n  }\n  for (const waypoint of $(node, \"wpt\")) {\n    const point = getPoint(waypoint);\n    if (point) yield point;\n  }\n}\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nfunction gpx(node) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(node))\n  };\n}\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\nconst TRACKPOINT_ATTRIBUTES = [[\"heartRate\", \"heartRates\"], [\"Cadence\", \"cadences\"],\n// Extended Trackpoint attributes\n[\"Speed\", \"speeds\"], [\"Watts\", \"watts\"]];\nconst LAP_ATTRIBUTES = [[\"TotalTimeSeconds\", \"totalTimeSeconds\"], [\"DistanceMeters\", \"distanceMeters\"], [\"MaximumSpeed\", \"maxSpeed\"], [\"AverageHeartRateBpm\", \"avgHeartRate\"], [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n// Extended Lap attributes\n[\"AvgSpeed\", \"avgSpeed\"], [\"AvgWatts\", \"avgWatts\"], [\"MaxWatts\", \"maxWatts\"]];\nfunction getProperties(node, attributeNames) {\n  const properties = [];\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n  return properties;\n}\nfunction coordPair(node) {\n  const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n  if (ll[0] === undefined || isNaN(ll[0]) || ll[1] === undefined || isNaN(ll[1])) {\n    return null;\n  }\n  const heartRate = get1(node, \"HeartRateBpm\");\n  const time = nodeVal(get1(node, \"Time\"));\n  get1(node, \"AltitudeMeters\", alt => {\n    const a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  });\n  return {\n    coordinates: ll,\n    time: time || null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(node, TRACKPOINT_ATTRIBUTES)\n  };\n}\nfunction getPoints(node) {\n  const pts = $(node, \"Trackpoint\");\n  const line = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const extendedProperties = {};\n  const result = {\n    extendedProperties\n  };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    const {\n      time,\n      heartRate,\n      extensions\n    } = c;\n    if (time) times.push(time);\n    if (heartRate) heartRates.push(heartRate);\n    for (const [alias, value] of extensions) {\n      if (!extendedProperties[alias]) {\n        extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      extendedProperties[alias][i] = value;\n    }\n  }\n  if (line.length < 2) return null;\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates\n  });\n}\nfunction getLap(node) {\n  const segments = $(node, \"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties = Object.assign(Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)), get(node, \"Name\", nameElement => {\n    return {\n      name: nodeVal(nameElement)\n    };\n  }));\n  for (const segment of segments) {\n    line = getPoints(segment);\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        if (line) {\n          properties[property] = line.extendedProperties[property];\n        }\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map(track => Array(track.length).fill(null));\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n  if (track.length === 0) return null;\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(times.length ? {\n      times: track.length === 1 ? times[0] : times\n    } : {}, heartRates.length ? {\n      heart: track.length === 1 ? heartRates[0] : heartRates\n    } : {});\n  }\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: track.length === 1 ? {\n      type: \"LineString\",\n      coordinates: track[0]\n    } : {\n      type: \"MultiLineString\",\n      coordinates: track\n    }\n  };\n}\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nfunction* tcxGen(node) {\n  for (const lap of $(node, \"Lap\")) {\n    const feature = getLap(lap);\n    if (feature) yield feature;\n  }\n  for (const course of $(node, \"Courses\")) {\n    const feature = getLap(course);\n    if (feature) yield feature;\n  }\n}\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nfunction tcx(node) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(node))\n  };\n}\nfunction fixColor(v, prefix) {\n  const properties = {};\n  const colorProp = prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v[0] === \"#\") {\n    v = v.substring(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = \"#\" + v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substring(0, 2), 16) / 255;\n    properties[colorProp] = \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return properties;\n}\nfunction numericProperty(node, source, target) {\n  const properties = {};\n  num1(node, source, val => {\n    properties[target] = val;\n  });\n  return properties;\n}\nfunction getColor(node, output) {\n  return get(node, \"color\", elem => fixColor(nodeVal(elem), output));\n}\nfunction extractIconHref(node) {\n  return get(node, \"Icon\", (icon, properties) => {\n    val1(icon, \"href\", href => {\n      properties.icon = href;\n    });\n    return properties;\n  });\n}\nfunction extractIcon(node) {\n  return get(node, \"IconStyle\", iconStyle => {\n    return Object.assign(getColor(iconStyle, \"icon\"), numericProperty(iconStyle, \"scale\", \"icon-scale\"), numericProperty(iconStyle, \"heading\", \"icon-heading\"), get(iconStyle, \"hotSpot\", hotspot => {\n      const left = parseFloat(hotspot.getAttribute(\"x\") || \"\");\n      const top = parseFloat(hotspot.getAttribute(\"y\") || \"\");\n      const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n      const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n      if (!isNaN(left) && !isNaN(top)) return {\n        \"icon-offset\": [left, top],\n        \"icon-offset-units\": [xunits, yunits]\n      };\n      return {};\n    }), extractIconHref(iconStyle));\n  });\n}\nfunction extractLabel(node) {\n  return get(node, \"LabelStyle\", labelStyle => {\n    return Object.assign(getColor(labelStyle, \"label\"), numericProperty(labelStyle, \"scale\", \"label-scale\"));\n  });\n}\nfunction extractLine(node) {\n  return get(node, \"LineStyle\", lineStyle => {\n    return Object.assign(getColor(lineStyle, \"stroke\"), numericProperty(lineStyle, \"width\", \"stroke-width\"));\n  });\n}\nfunction extractPoly(node) {\n  return get(node, \"PolyStyle\", (polyStyle, properties) => {\n    return Object.assign(properties, get(polyStyle, \"color\", elem => fixColor(nodeVal(elem), \"fill\")), val1(polyStyle, \"fill\", fill => {\n      if (fill === \"0\") return {\n        \"fill-opacity\": 0\n      };\n    }), val1(polyStyle, \"outline\", outline => {\n      if (outline === \"0\") return {\n        \"stroke-opacity\": 0\n      };\n    }));\n  });\n}\nfunction extractStyle(node) {\n  return Object.assign({}, extractPoly(node), extractLine(node), extractLabel(node), extractIcon(node));\n}\nconst toNumber = x => Number(x);\nconst typeConverters = {\n  string: x => x,\n  int: toNumber,\n  uint: toNumber,\n  short: toNumber,\n  ushort: toNumber,\n  float: toNumber,\n  double: toNumber,\n  bool: x => Boolean(x)\n};\nfunction extractExtendedData(node, schema) {\n  return get(node, \"ExtendedData\", (extendedData, properties) => {\n    for (const data of $(extendedData, \"Data\")) {\n      properties[data.getAttribute(\"name\") || \"\"] = nodeVal(get1(data, \"value\"));\n    }\n    for (const simpleData of $(extendedData, \"SimpleData\")) {\n      const name = simpleData.getAttribute(\"name\") || \"\";\n      const typeConverter = schema[name] || typeConverters.string;\n      properties[name] = typeConverter(nodeVal(simpleData));\n    }\n    return properties;\n  });\n}\nfunction getMaybeHTMLDescription(node) {\n  const descriptionNode = get1(node, \"description\");\n  for (const c of Array.from(descriptionNode?.childNodes || [])) {\n    if (c.nodeType === 4) {\n      return {\n        description: {\n          \"@type\": \"html\",\n          value: nodeVal(c)\n        }\n      };\n    }\n  }\n  return {};\n}\nfunction extractTimeSpan(node) {\n  return get(node, \"TimeSpan\", timeSpan => {\n    return {\n      timespan: {\n        begin: nodeVal(get1(timeSpan, \"begin\")),\n        end: nodeVal(get1(timeSpan, \"end\"))\n      }\n    };\n  });\n}\nfunction extractTimeStamp(node) {\n  return get(node, \"TimeStamp\", timeStamp => {\n    return {\n      timestamp: nodeVal(get1(timeStamp, \"when\"))\n    };\n  });\n}\nfunction extractCascadedStyle(node, styleMap) {\n  return val1(node, \"styleUrl\", styleUrl => {\n    styleUrl = normalizeId(styleUrl);\n    if (styleMap[styleUrl]) {\n      return Object.assign({\n        styleUrl\n      }, styleMap[styleUrl]);\n    }\n    // For backward-compatibility. Should we still include\n    // styleUrl even if it's not resolved?\n    return {\n      styleUrl\n    };\n  });\n}\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n/**\n * Get one coordinate from a coordinate array, if any\n */\nfunction coord1(value) {\n  return value.replace(removeSpace, \"\").split(\",\").map(parseFloat).filter(num => !isNaN(num)).slice(0, 3);\n}\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nfunction coord(value) {\n  return value.replace(trimSpace, \"\").split(splitSpace).map(coord1).filter(coord => {\n    return coord.length >= 2;\n  });\n}\nfunction gxCoords(node) {\n  let elems = $(node, \"coord\");\n  if (elems.length === 0) {\n    elems = $ns(node, \"coord\", \"*\");\n  }\n  const coordinates = elems.map(elem => {\n    return nodeVal(elem).split(\" \").map(parseFloat);\n  });\n  if (coordinates.length === 0) {\n    return null;\n  }\n  return {\n    geometry: coordinates.length > 2 ? {\n      type: \"LineString\",\n      coordinates\n    } : {\n      type: \"Point\",\n      coordinates: coordinates[0]\n    },\n    times: $(node, \"when\").map(elem => nodeVal(elem))\n  };\n}\nfunction fixRing(ring) {\n  if (ring.length === 0) return ring;\n  const first = ring[0];\n  const last = ring[ring.length - 1];\n  let equal = true;\n  for (let i = 0; i < Math.max(first.length, last.length); i++) {\n    if (first[i] !== last[i]) {\n      equal = false;\n      break;\n    }\n  }\n  if (!equal) {\n    return ring.concat([ring[0]]);\n  }\n  return ring;\n}\nfunction getCoordinates(node) {\n  return nodeVal(get1(node, \"coordinates\"));\n}\nfunction getGeometry(node) {\n  let geometries = [];\n  let coordTimes = [];\n  for (let i = 0; i < node.childNodes.length; i++) {\n    const child = node.childNodes.item(i);\n    if (isElement(child)) {\n      switch (child.tagName) {\n        case \"MultiGeometry\":\n        case \"MultiTrack\":\n        case \"gx:MultiTrack\":\n          {\n            const childGeometries = getGeometry(child);\n            geometries = geometries.concat(childGeometries.geometries);\n            coordTimes = coordTimes.concat(childGeometries.coordTimes);\n            break;\n          }\n        case \"Point\":\n          {\n            const coordinates = coord1(getCoordinates(child));\n            if (coordinates.length >= 2) {\n              geometries.push({\n                type: \"Point\",\n                coordinates\n              });\n            }\n            break;\n          }\n        case \"LinearRing\":\n        case \"LineString\":\n          {\n            const coordinates = coord(getCoordinates(child));\n            if (coordinates.length >= 2) {\n              geometries.push({\n                type: \"LineString\",\n                coordinates\n              });\n            }\n            break;\n          }\n        case \"Polygon\":\n          {\n            const coords = [];\n            for (const linearRing of $(child, \"LinearRing\")) {\n              const ring = fixRing(coord(getCoordinates(linearRing)));\n              if (ring.length >= 4) {\n                coords.push(ring);\n              }\n            }\n            if (coords.length) {\n              geometries.push({\n                type: \"Polygon\",\n                coordinates: coords\n              });\n            }\n            break;\n          }\n        case \"Track\":\n        case \"gx:Track\":\n          {\n            const gx = gxCoords(child);\n            if (!gx) break;\n            const {\n              times,\n              geometry\n            } = gx;\n            geometries.push(geometry);\n            if (times.length) coordTimes.push(times);\n            break;\n          }\n      }\n    }\n  }\n  return {\n    geometries,\n    coordTimes\n  };\n}\nfunction geometryListToGeometry(geometries) {\n  return geometries.length === 0 ? null : geometries.length === 1 ? geometries[0] : {\n    type: \"GeometryCollection\",\n    geometries\n  };\n}\nfunction getPlacemark(node, styleMap, schema, options) {\n  const {\n    coordTimes,\n    geometries\n  } = getGeometry(node);\n  const geometry = geometryListToGeometry(geometries);\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(getMulti(node, [\"name\", \"address\", \"visibility\", \"open\", \"phoneNumber\", \"description\"]), getMaybeHTMLDescription(node), extractCascadedStyle(node, styleMap), extractStyle(node), extractExtendedData(node, schema), extractTimeSpan(node), extractTimeStamp(node), coordTimes.length ? {\n      coordinateProperties: {\n        times: coordTimes.length === 1 ? coordTimes[0] : coordTimes\n      }\n    } : {})\n  };\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\nfunction getGroundOverlayBox(node) {\n  const latLonQuad = get1(node, \"gx:LatLonQuad\");\n  if (latLonQuad) {\n    const ring = fixRing(coord(getCoordinates(node)));\n    return {\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [ring]\n      }\n    };\n  }\n  return getLatLonBox(node);\n}\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nfunction rotateBox(bbox, coordinates, rotation) {\n  const center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n  return [coordinates[0].map(coordinate => {\n    const dy = coordinate[1] - center[1];\n    const dx = coordinate[0] - center[0];\n    const distance = Math.sqrt(Math.pow(dy, 2) + Math.pow(dx, 2));\n    const angle = Math.atan2(dy, dx) + rotation * DEGREES_TO_RADIANS;\n    return [center[0] + Math.cos(angle) * distance, center[1] + Math.sin(angle) * distance];\n  })];\n}\nfunction getLatLonBox(node) {\n  const latLonBox = get1(node, \"LatLonBox\");\n  if (latLonBox) {\n    const north = num1(latLonBox, \"north\");\n    const west = num1(latLonBox, \"west\");\n    const east = num1(latLonBox, \"east\");\n    const south = num1(latLonBox, \"south\");\n    const rotation = num1(latLonBox, \"rotation\");\n    if (typeof north === \"number\" && typeof south === \"number\" && typeof west === \"number\" && typeof east === \"number\") {\n      const bbox = [west, south, east, north];\n      let coordinates = [[[west, north], [east, north], [east, south], [west, south], [west, north] // top left (again)\n      ]];\n      if (typeof rotation === \"number\") {\n        coordinates = rotateBox(bbox, coordinates, rotation);\n      }\n      return {\n        bbox,\n        geometry: {\n          type: \"Polygon\",\n          coordinates\n        }\n      };\n    }\n  }\n  return null;\n}\nfunction getGroundOverlay(node, styleMap, schema, options) {\n  const box = getGroundOverlayBox(node);\n  const geometry = box?.geometry || null;\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n    /**\n     * Related to\n     * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46\n     */\n    {\n      \"@geometry-type\": \"groundoverlay\"\n    }, getMulti(node, [\"name\", \"address\", \"visibility\", \"open\", \"phoneNumber\", \"description\"]), getMaybeHTMLDescription(node), extractCascadedStyle(node, styleMap), extractStyle(node), extractIconHref(node), extractExtendedData(node, schema), extractTimeSpan(node), extractTimeStamp(node))\n  };\n  if (box?.bbox) {\n    feature.bbox = box.bbox;\n  }\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\nfunction getStyleId(style) {\n  let id = style.getAttribute(\"id\");\n  const parentNode = style.parentNode;\n  if (!id && isElement(parentNode) && parentNode.localName === \"CascadingStyle\") {\n    id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n  }\n  return normalizeId(id || \"\");\n}\nfunction buildStyleMap(node) {\n  const styleMap = {};\n  for (const style of $(node, \"Style\")) {\n    styleMap[getStyleId(style)] = extractStyle(style);\n  }\n  for (const map of $(node, \"StyleMap\")) {\n    const id = normalizeId(map.getAttribute(\"id\") || \"\");\n    val1(map, \"styleUrl\", styleUrl => {\n      styleUrl = normalizeId(styleUrl);\n      if (styleMap[styleUrl]) {\n        styleMap[id] = styleMap[styleUrl];\n      }\n    });\n  }\n  return styleMap;\n}\nfunction buildSchema(node) {\n  const schema = {};\n  for (const field of $(node, \"SimpleField\")) {\n    schema[field.getAttribute(\"name\") || \"\"] = typeConverters[field.getAttribute(\"type\") || \"\"] || typeConverters[\"string\"];\n  }\n  return schema;\n}\nconst FOLDER_PROPS = [\"name\", \"visibility\", \"open\", \"address\", \"description\", \"phoneNumber\", \"visibility\"];\nfunction getFolder(node) {\n  const meta = {};\n  for (const child of Array.from(node.childNodes)) {\n    if (isElement(child) && FOLDER_PROPS.includes(child.tagName)) {\n      meta[child.tagName] = nodeVal(child);\n    }\n  }\n  return {\n    type: \"folder\",\n    meta,\n    children: []\n  };\n}\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n *\n * ### GroundOverlay\n *\n * GroundOverlay elements are converted into\n * `Feature` objects with `Polygon` geometries,\n * a property like:\n *\n * ```json\n * {\n *   \"@geometry-type\": \"groundoverlay\"\n * }\n * ```\n *\n * And the ground overlay's image URL in the `href`\n * property. Ground overlays will need to be displayed\n * with a separate method to other features, depending\n * on which map framework you're using.\n */\nfunction kmlWithFolders(node, options = {\n  skipNullGeometry: false\n}) {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n  const tree = {\n    type: \"root\",\n    children: []\n  };\n  function traverse(node, pointer, options) {\n    if (isElement(node)) {\n      switch (node.tagName) {\n        case \"GroundOverlay\":\n          {\n            const placemark = getGroundOverlay(node, styleMap, schema, options);\n            if (placemark) {\n              pointer.children.push(placemark);\n            }\n            break;\n          }\n        case \"Placemark\":\n          {\n            const placemark = getPlacemark(node, styleMap, schema, options);\n            if (placemark) {\n              pointer.children.push(placemark);\n            }\n            break;\n          }\n        case \"Folder\":\n          {\n            const folder = getFolder(node);\n            pointer.children.push(folder);\n            pointer = folder;\n            break;\n          }\n      }\n    }\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        traverse(node.childNodes[i], pointer, options);\n      }\n    }\n  }\n  traverse(node, tree, options);\n  return tree;\n}\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nfunction* kmlGen(node, options = {\n  skipNullGeometry: false\n}) {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n  for (const placemark of $(node, \"Placemark\")) {\n    const feature = getPlacemark(placemark, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n  for (const groundOverlay of $(node, \"GroundOverlay\")) {\n    const feature = getGroundOverlay(groundOverlay, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n}\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nfunction kml(node, options = {\n  skipNullGeometry: false\n}) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(node, options))\n  };\n}\nexport { gpx, gpxGen, kml, kmlGen, kmlWithFolders, tcx, tcxGen };","map":{"version":3,"names":["$","element","tagName","Array","from","getElementsByTagName","normalizeId","id","$ns","ns","getElementsByTagNameNS","nodeVal","node","normalize","textContent","get1","callback","n","result","length","get","properties","val1","val","$num","parseFloat","isNaN","undefined","num1","getMulti","propertyNames","property","isElement","nodeType","getLineStyle","lineStyle","Object","assign","color","stroke","opacity","width","getExtensions","values","child","childNodes","name","abbreviateName","nodeName","concat","push","parseNumeric","includes","num","coordPair$1","coordPair","ll","getAttribute","time","coordinates","extendedValues","extractProperties","extensions","parentNode","replace","links","map","link","href","getPoints$1","getPoints","pointname","pts","line","times","i","c","plural","fill","getRoute","type","_gpxType","geometry","getTrack","segments","track","extractedLines","segment","multi","coordinateProperties","props","entries","getPoint","pair","gpxGen","feature","route","waypoint","point","gpx","features","EXTENSIONS_NS","TRACKPOINT_ATTRIBUTES","LAP_ATTRIBUTES","getProperties","attributeNames","tag","alias","elem","elements","heartRate","alt","a","heartRates","extendedProperties","value","getLap","allExtendedProperties","fromEntries","nameElement","heart","tcxGen","lap","course","tcx","fixColor","v","prefix","colorProp","substring","parseInt","numericProperty","source","target","getColor","output","extractIconHref","icon","extractIcon","iconStyle","hotspot","left","top","xunits","yunits","extractLabel","labelStyle","extractLine","extractPoly","polyStyle","outline","extractStyle","toNumber","x","Number","typeConverters","string","int","uint","short","ushort","float","double","bool","Boolean","extractExtendedData","schema","extendedData","data","simpleData","typeConverter","getMaybeHTMLDescription","descriptionNode","description","extractTimeSpan","timeSpan","timespan","begin","end","extractTimeStamp","timeStamp","timestamp","extractCascadedStyle","styleMap","styleUrl","removeSpace","trimSpace","splitSpace","coord1","split","filter","slice","coord","gxCoords","elems","fixRing","ring","first","last","equal","Math","max","getCoordinates","getGeometry","geometries","coordTimes","item","childGeometries","coords","linearRing","gx","geometryListToGeometry","getPlacemark","options","skipNullGeometry","visibility","getGroundOverlayBox","latLonQuad","getLatLonBox","DEGREES_TO_RADIANS","PI","rotateBox","bbox","rotation","center","coordinate","dy","dx","distance","sqrt","pow","angle","atan2","cos","sin","latLonBox","north","west","east","south","getGroundOverlay","box","getStyleId","style","localName","buildStyleMap","buildSchema","field","FOLDER_PROPS","getFolder","meta","children","kmlWithFolders","tree","traverse","pointer","placemark","folder","kmlGen","groundOverlay","kml"],"sources":["C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\shared.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\gpx\\line.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\gpx\\extensions.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\gpx\\coord_pair.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\gpx\\properties.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\gpx.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\tcx.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\kml\\fixColor.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\kml\\extractStyle.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\kml\\shared.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\kml\\geometry.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\kml\\placemark.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\kml\\ground_overlay.ts","C:\\Users\\Admin\\Desktop\\GeoData\\App\\Client\\node_modules\\@tmcw\\togeojson\\lib\\lib\\kml.ts"],"sourcesContent":["import type { Feature, Geometry } from \"geojson\";\n\nexport function $(element: Element | Document, tagName: string): Element[] {\n  return Array.from(element.getElementsByTagName(tagName));\n}\n\nexport type P = NonNullable<Feature[\"properties\"]>;\nexport type F = Feature<Geometry | null>;\n\nexport type StyleMap = { [key: string]: P };\n\nexport function normalizeId(id: string) {\n  return id[0] === \"#\" ? id : `#${id}`;\n}\n\nexport function $ns(\n  element: Element | Document,\n  tagName: string,\n  ns: string\n): Element[] {\n  return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n\n/**\n * get the content of a text node, if any\n */\nexport function nodeVal(node: Element | null) {\n  node?.normalize();\n  return (node && node.textContent) || \"\";\n}\n\n/**\n * Get one Y child of X, if any, otherwise null\n */\nexport function get1(\n  node: Element,\n  tagName: string,\n  callback?: (elem: Element) => unknown\n) {\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) callback(result);\n  return result;\n}\n\nexport function get(\n  node: Element | null,\n  tagName: string,\n  callback?: (elem: Element, properties: P) => P\n) {\n  const properties: Feature[\"properties\"] = {};\n  if (!node) return properties;\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) {\n    return callback(result, properties);\n  }\n  return properties;\n}\n\nexport function val1(\n  node: Element,\n  tagName: string,\n  callback: (val: string) => P | void\n): P {\n  const val = nodeVal(get1(node, tagName));\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function $num(\n  node: Element,\n  tagName: string,\n  callback: (val: number) => Feature[\"properties\"]\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function num1(\n  node: Element,\n  tagName: string,\n  callback?: (val: number) => unknown\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (callback) callback(val);\n  return val;\n}\n\nexport function getMulti(node: Element, propertyNames: string[]): P {\n  const properties: P = {};\n  for (const property of propertyNames) {\n    val1(node, property, (val) => {\n      properties[property] = val;\n    });\n  }\n  return properties;\n}\n\nexport function isElement(node: Node | null): node is Element {\n  return node?.nodeType === 1;\n}\n","import { get, P, val1, $num } from \"../shared\";\n\nexport function getLineStyle(node: Element | null) {\n  return get(node, \"line\", (lineStyle) => {\n    const val: P = Object.assign(\n      {},\n      val1(lineStyle, \"color\", (color) => {\n        return { stroke: `#${color}` };\n      }),\n      $num(lineStyle, \"opacity\", (opacity) => {\n        return { \"stroke-opacity\": opacity };\n      }),\n      $num(lineStyle, \"width\", (width) => {\n        // GPX width is in mm, convert to px with 96 px per inch\n        return { \"stroke-width\": (width * 96) / 25.4 };\n      })\n    );\n    return val;\n  });\n}\n","import { isElement, nodeVal } from \"../shared\";\n\nexport type ExtendedValues = [string, string | number][];\n\nexport function getExtensions(node: Element | null): ExtendedValues {\n  let values: [string, string | number][] = [];\n  if (node === null) return values;\n  for (const child of Array.from(node.childNodes)) {\n    if (!isElement(child)) continue;\n    const name = abbreviateName(child.nodeName);\n    if (name === \"gpxtpx:TrackPointExtension\") {\n      // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n      values = values.concat(getExtensions(child));\n    } else {\n      // push custom extension (eg. \"power\")\n      const val = nodeVal(child);\n      values.push([name, parseNumeric(val)]);\n    }\n  }\n  return values;\n}\n\nfunction abbreviateName(name: string) {\n  return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\n\nfunction parseNumeric(val: string) {\n  const num = parseFloat(val);\n  return isNaN(num) ? val : num;\n}\n","import { Position } from \"geojson\";\nimport { num1, get1, nodeVal } from \"../shared\";\nimport { ExtendedValues, getExtensions } from \"./extensions\";\n\ninterface CoordPair {\n  coordinates: Position;\n  time: string | null;\n  extendedValues: ExtendedValues;\n}\n\nexport function coordPair(node: Element): CoordPair | null {\n  const ll = [\n    parseFloat(node.getAttribute(\"lon\") || \"\"),\n    parseFloat(node.getAttribute(\"lat\") || \"\"),\n  ];\n\n  if (isNaN(ll[0]) || isNaN(ll[1])) {\n    return null;\n  }\n\n  num1(node, \"ele\", (val) => {\n    ll.push(val);\n  });\n\n  const time = get1(node, \"time\");\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(node, \"extensions\")),\n  };\n}\n","import { $, getMulti, nodeVal } from \"../shared\";\n\nexport function extractProperties(node: Element) {\n  const properties = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n\n  const extensions = Array.from(\n    node.getElementsByTagNameNS(\n      \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n      \"*\"\n    )\n  );\n  for (const child of extensions) {\n    if (child.parentNode?.parentNode === node) {\n      properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child);\n    }\n  }\n\n  const links = $(node, \"link\");\n  if (links.length) {\n    properties.links = links.map((link) =>\n      Object.assign(\n        { href: link.getAttribute(\"href\") },\n        getMulti(link, [\"text\", \"type\"])\n      )\n    );\n  }\n\n  return properties;\n}\n","import type {\n  FeatureCollection,\n  Feature,\n  Point,\n  MultiLineString,\n  LineString,\n  Position,\n} from \"geojson\";\nimport { getLineStyle } from \"./gpx/line\";\nimport { coordPair } from \"./gpx/coord_pair\";\nimport { extractProperties } from \"./gpx/properties\";\nimport { P, $, get1, getMulti } from \"./shared\";\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints(node: Element, pointname: \"trkpt\" | \"rtept\") {\n  const pts = $(node, pointname);\n  const line: Position[] = [];\n  const times = [];\n  const extendedValues: P = {};\n\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (!c) {\n      continue;\n    }\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (const [name, val] of c.extendedValues) {\n      const plural =\n        name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n\n  if (line.length < 2) return; // Invalid line in GeoJSON\n\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(node: Element): Feature<LineString> | undefined {\n  const line = getPoints(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      { _gpxType: \"rte\" },\n      extractProperties(node),\n      getLineStyle(get1(node, \"extensions\"))\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getTrack(node: Element): Feature<LineString | MultiLineString> | null {\n  const segments = $(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (const segment of segments) {\n    const line = getPoints(segment, \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return null;\n\n  const multi = extractedLines.length > 1;\n\n  const properties: Feature[\"properties\"] = Object.assign(\n    { _gpxType: \"trk\" },\n    extractProperties(node),\n    getLineStyle(get1(node, \"extensions\")),\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          },\n        }\n      : {}\n  );\n\n  for (const line of extractedLines) {\n    track.push(line.line);\n    if (!properties.coordinateProperties) {\n      properties.coordinateProperties = {};\n    }\n    const props = properties.coordinateProperties;\n    const entries = Object.entries(line.extendedValues);\n    for (let i = 0; i < entries.length; i++) {\n      const [name, val] = entries[i];\n      if (multi) {\n        if (!props[name]) {\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        }\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n          type: \"MultiLineString\",\n          coordinates: track,\n        }\n      : {\n          type: \"LineString\",\n          coordinates: track[0],\n        },\n  };\n}\n\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(node: Element): Feature<Point> | null {\n  const properties: Feature[\"properties\"] = Object.assign(\n    extractProperties(node),\n    getMulti(node, [\"sym\"])\n  );\n  const pair = coordPair(node);\n  if (!pair) return null;\n  return {\n    type: \"Feature\",\n    properties,\n    geometry: {\n      type: \"Point\",\n      coordinates: pair.coordinates,\n    },\n  };\n}\n\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* gpxGen(node: Document): Generator<Feature> {\n  for (const track of $(node, \"trk\")) {\n    const feature = getTrack(track);\n    if (feature) yield feature;\n  }\n\n  for (const route of $(node, \"rte\")) {\n    const feature = getRoute(route);\n    if (feature) yield feature;\n  }\n\n  for (const waypoint of $(node, \"wpt\")) {\n    const point = getPoint(waypoint);\n    if (point) yield point;\n  }\n}\n\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nexport function gpx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(node)),\n  };\n}\n","import { Feature, FeatureCollection, Position } from \"geojson\";\nimport { P, $, get, num1, nodeVal, get1 } from \"./shared\";\n\ntype PropertyMapping = readonly [string, string][];\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES: PropertyMapping = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES: PropertyMapping = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction getProperties(node: Element, attributeNames: PropertyMapping) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(node: Element) {\n  const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n  if (\n    ll[0] === undefined ||\n    isNaN(ll[0]) ||\n    ll[1] === undefined ||\n    isNaN(ll[1])\n  ) {\n    return null;\n  }\n  const heartRate = get1(node, \"HeartRateBpm\");\n  const time = nodeVal(get1(node, \"Time\"));\n  get1(node, \"AltitudeMeters\", (alt) => {\n    const a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  });\n  return {\n    coordinates: ll as number[],\n    time: time || null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(node, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node: Element) {\n  const pts = $(node, \"Trackpoint\");\n  const line: Position[] = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const extendedProperties: P = {};\n  const result = { extendedProperties };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    const { time, heartRate, extensions } = c;\n    if (time) times.push(time);\n    if (heartRate) heartRates.push(heartRate);\n    for (const [alias, value] of extensions) {\n      if (!extendedProperties[alias]) {\n        extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      extendedProperties[alias][i] = value;\n    }\n  }\n  if (line.length < 2) return null;\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node: Element): Feature | null {\n  const segments = $(node, \"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties: P = Object.assign(\n    Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)),\n    get(node, \"Name\", (nameElement) => {\n      return { name: nodeVal(nameElement) };\n    })\n  );\n\n  for (const segment of segments) {\n    line = getPoints(segment);\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        if (line) {\n          properties[property] = line.extendedProperties[property];\n        }\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n\n  if (track.length === 0) return null;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry:\n      track.length === 1\n        ? {\n            type: \"LineString\",\n            coordinates: track[0],\n          }\n        : {\n            type: \"MultiLineString\",\n            coordinates: track,\n          },\n  };\n}\n\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function* tcxGen(node: Document): Generator<Feature> {\n  for (const lap of $(node, \"Lap\")) {\n    const feature = getLap(lap);\n    if (feature) yield feature;\n  }\n\n  for (const course of $(node, \"Courses\")) {\n    const feature = getLap(course);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function tcx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(node)),\n  };\n}\n","import { P } from \"../shared\";\n\nexport function fixColor(v: string, prefix: string): P {\n  const properties: P = {};\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v[0] === \"#\") {\n    v = v.substring(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = \"#\" + v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substring(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return properties;\n}\n","import { P, get, num1, nodeVal, val1 } from \"../shared\";\nimport { fixColor } from \"./fixColor\";\n\nfunction numericProperty(node: Element, source: string, target: string): P {\n  const properties: P = {};\n  num1(node, source, (val) => {\n    properties[target] = val;\n  });\n  return properties;\n}\n\nfunction getColor(node: Element, output: string): P {\n  return get(node, \"color\", (elem) => fixColor(nodeVal(elem), output));\n}\n\nexport function extractIconHref(node: Element) {\n  return get(node, \"Icon\", (icon, properties) => {\n    val1(icon, \"href\", (href) => {\n      properties.icon = href;\n    });\n    return properties;\n  });\n}\n\nexport function extractIcon(node: Element) {\n  return get(node, \"IconStyle\", (iconStyle) => {\n    return Object.assign(\n      getColor(iconStyle, \"icon\"),\n      numericProperty(iconStyle, \"scale\", \"icon-scale\"),\n      numericProperty(iconStyle, \"heading\", \"icon-heading\"),\n      get(iconStyle, \"hotSpot\", (hotspot) => {\n        const left = parseFloat(hotspot.getAttribute(\"x\") || \"\");\n        const top = parseFloat(hotspot.getAttribute(\"y\") || \"\");\n        const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n        const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n        if (!isNaN(left) && !isNaN(top))\n          return {\n            \"icon-offset\": [left, top],\n            \"icon-offset-units\": [xunits, yunits],\n          };\n        return {};\n      }),\n      extractIconHref(iconStyle)\n    );\n  });\n}\n\nexport function extractLabel(node: Element) {\n  return get(node, \"LabelStyle\", (labelStyle) => {\n    return Object.assign(\n      getColor(labelStyle, \"label\"),\n      numericProperty(labelStyle, \"scale\", \"label-scale\")\n    );\n  });\n}\n\nexport function extractLine(node: Element) {\n  return get(node, \"LineStyle\", (lineStyle) => {\n    return Object.assign(\n      getColor(lineStyle, \"stroke\"),\n      numericProperty(lineStyle, \"width\", \"stroke-width\")\n    );\n  });\n}\n\nexport function extractPoly(node: Element) {\n  return get(node, \"PolyStyle\", (polyStyle, properties) => {\n    return Object.assign(\n      properties,\n      get(polyStyle, \"color\", (elem) => fixColor(nodeVal(elem), \"fill\")),\n      val1(polyStyle, \"fill\", (fill) => {\n        if (fill === \"0\") return { \"fill-opacity\": 0 };\n      }),\n      val1(polyStyle, \"outline\", (outline) => {\n        if (outline === \"0\") return { \"stroke-opacity\": 0 };\n      })\n    );\n  });\n}\n\nexport function extractStyle(node: Element) {\n  return Object.assign(\n    {},\n    extractPoly(node),\n    extractLine(node),\n    extractLabel(node),\n    extractIcon(node)\n  );\n}\n","import {\n  get,\n  get1,\n  nodeVal,\n  $,\n  normalizeId,\n  P,\n  StyleMap,\n  val1,\n} from \"../shared\";\n\nexport type TypeConverter = (x: string) => unknown;\nexport type Schema = { [key: string]: TypeConverter };\n\nconst toNumber: TypeConverter = (x) => Number(x);\nexport const typeConverters: Record<string, TypeConverter> = {\n  string: (x) => x,\n  int: toNumber,\n  uint: toNumber,\n  short: toNumber,\n  ushort: toNumber,\n  float: toNumber,\n  double: toNumber,\n  bool: (x) => Boolean(x),\n};\n\nexport function extractExtendedData(node: Element, schema: Schema) {\n  return get(node, \"ExtendedData\", (extendedData, properties) => {\n    for (const data of $(extendedData, \"Data\")) {\n      properties[data.getAttribute(\"name\") || \"\"] = nodeVal(\n        get1(data, \"value\")\n      );\n    }\n    for (const simpleData of $(extendedData, \"SimpleData\")) {\n      const name = simpleData.getAttribute(\"name\") || \"\";\n      const typeConverter = schema[name] || typeConverters.string;\n      properties[name] = typeConverter(nodeVal(simpleData));\n    }\n    return properties;\n  });\n}\n\nexport function getMaybeHTMLDescription(node: Element) {\n  const descriptionNode = get1(node, \"description\");\n  for (const c of Array.from(descriptionNode?.childNodes || [])) {\n    if (c.nodeType === 4) {\n      return {\n        description: {\n          \"@type\": \"html\",\n          value: nodeVal(c as Element),\n        },\n      };\n    }\n  }\n  return {};\n}\n\nexport function extractTimeSpan(node: Element): P {\n  return get(node, \"TimeSpan\", (timeSpan) => {\n    return {\n      timespan: {\n        begin: nodeVal(get1(timeSpan, \"begin\")),\n        end: nodeVal(get1(timeSpan, \"end\")),\n      },\n    };\n  });\n}\n\nexport function extractTimeStamp(node: Element): P {\n  return get(node, \"TimeStamp\", (timeStamp) => {\n    return { timestamp: nodeVal(get1(timeStamp, \"when\")) };\n  });\n}\n\nexport function extractCascadedStyle(node: Element, styleMap: StyleMap): P {\n  return val1(node, \"styleUrl\", (styleUrl) => {\n    styleUrl = normalizeId(styleUrl);\n    if (styleMap[styleUrl]) {\n      return Object.assign({ styleUrl }, styleMap[styleUrl]);\n    }\n    // For backward-compatibility. Should we still include\n    // styleUrl even if it's not resolved?\n    return { styleUrl };\n  });\n}\n","import { Position, Point, LineString, Geometry } from \"geojson\";\nimport { $, $ns, nodeVal, get1, isElement } from \"../shared\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n/**\n * Get one coordinate from a coordinate array, if any\n */\nexport function coord1(value: string): Position {\n  return value\n    .replace(removeSpace, \"\")\n    .split(\",\")\n    .map(parseFloat)\n    .filter((num) => !isNaN(num))\n    .slice(0, 3);\n}\n\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nexport function coord(value: string): Position[] {\n  return value\n    .replace(trimSpace, \"\")\n    .split(splitSpace)\n    .map(coord1)\n    .filter((coord) => {\n      return coord.length >= 2;\n    });\n}\n\nfunction gxCoords(\n  node: Element\n): { geometry: Point | LineString; times: string[] } | null {\n  let elems = $(node, \"coord\");\n  if (elems.length === 0) {\n    elems = $ns(node, \"coord\", \"*\");\n  }\n\n  const coordinates = elems.map((elem) => {\n    return nodeVal(elem).split(\" \").map(parseFloat);\n  });\n\n  if (coordinates.length === 0) {\n    return null;\n  }\n\n  return {\n    geometry:\n      coordinates.length > 2\n        ? {\n            type: \"LineString\",\n            coordinates,\n          }\n        : {\n            type: \"Point\",\n            coordinates: coordinates[0],\n          },\n    times: $(node, \"when\").map((elem) => nodeVal(elem)),\n  };\n}\n\nexport function fixRing(ring: Position[]) {\n  if (ring.length === 0) return ring;\n  const first = ring[0];\n  const last = ring[ring.length - 1];\n  let equal = true;\n  for (let i = 0; i < Math.max(first.length, last.length); i++) {\n    if (first[i] !== last[i]) {\n      equal = false;\n      break;\n    }\n  }\n  if (!equal) {\n    return ring.concat([ring[0]]);\n  }\n  return ring;\n}\n\nexport function getCoordinates(node: Element) {\n  return nodeVal(get1(node, \"coordinates\"));\n}\n\ninterface GeometriesAndTimes {\n  geometries: Geometry[];\n  coordTimes: string[][];\n}\n\nexport function getGeometry(node: Element): GeometriesAndTimes {\n  let geometries: Geometry[] = [];\n  let coordTimes: string[][] = [];\n\n  for (let i = 0; i < node.childNodes.length; i++) {\n    const child = node.childNodes.item(i);\n    if (isElement(child)) {\n      switch (child.tagName) {\n        case \"MultiGeometry\":\n        case \"MultiTrack\":\n        case \"gx:MultiTrack\": {\n          const childGeometries = getGeometry(child);\n          geometries = geometries.concat(childGeometries.geometries);\n          coordTimes = coordTimes.concat(childGeometries.coordTimes);\n          break;\n        }\n\n        case \"Point\": {\n          const coordinates = coord1(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"Point\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"LinearRing\":\n        case \"LineString\": {\n          const coordinates = coord(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"LineString\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"Polygon\": {\n          const coords = [];\n          for (const linearRing of $(child, \"LinearRing\")) {\n            const ring = fixRing(coord(getCoordinates(linearRing)));\n            if (ring.length >= 4) {\n              coords.push(ring);\n            }\n          }\n          if (coords.length) {\n            geometries.push({\n              type: \"Polygon\",\n              coordinates: coords,\n            });\n          }\n          break;\n        }\n        case \"Track\":\n        case \"gx:Track\": {\n          const gx = gxCoords(child);\n          if (!gx) break;\n          const { times, geometry } = gx;\n          geometries.push(geometry);\n          if (times.length) coordTimes.push(times);\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    geometries,\n    coordTimes,\n  };\n}\n","import { Feature, Geometry } from \"geojson\";\nimport { StyleMap, getMulti } from \"../shared\";\nimport {\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n  Schema,\n} from \"./shared\";\nimport { extractStyle } from \"./extractStyle\";\nimport { getGeometry } from \"./geometry\";\nimport { KMLOptions } from \"lib/kml\";\n\nfunction geometryListToGeometry(geometries: Geometry[]): Geometry | null {\n  return geometries.length === 0\n    ? null\n    : geometries.length === 1\n    ? geometries[0]\n    : {\n        type: \"GeometryCollection\",\n        geometries,\n      };\n}\n\nexport function getPlacemark(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Geometry | null> | null {\n  const { coordTimes, geometries } = getGeometry(node);\n\n  const geometry = geometryListToGeometry(geometries);\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Geometry | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node),\n      coordTimes.length\n        ? {\n            coordinateProperties: {\n              times: coordTimes.length === 1 ? coordTimes[0] : coordTimes,\n            },\n          }\n        : {}\n    ),\n  };\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n","import { Feature, Polygon } from \"geojson\";\nimport { StyleMap, get1, num1, getMulti } from \"../shared\";\nimport {\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n  Schema,\n} from \"./shared\";\nimport { extractIconHref, extractStyle } from \"./extractStyle\";\nimport { coord, fixRing, getCoordinates } from \"./geometry\";\nimport { KMLOptions } from \"lib/kml\";\n\ninterface BoxGeometry {\n  bbox?: BBox;\n  geometry: Polygon;\n}\n\nfunction getGroundOverlayBox(node: Element): BoxGeometry | null {\n  const latLonQuad = get1(node, \"gx:LatLonQuad\");\n\n  if (latLonQuad) {\n    const ring = fixRing(coord(getCoordinates(node)));\n    return {\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [ring],\n      },\n    };\n  }\n\n  return getLatLonBox(node);\n}\n\ntype BBox = [number, number, number, number];\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction rotateBox(\n  bbox: BBox,\n  coordinates: Polygon[\"coordinates\"],\n  rotation: number\n): Polygon[\"coordinates\"] {\n  const center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n\n  return [\n    coordinates[0].map((coordinate) => {\n      const dy = coordinate[1] - center[1];\n      const dx = coordinate[0] - center[0];\n      const distance = Math.sqrt(Math.pow(dy, 2) + Math.pow(dx, 2));\n      const angle = Math.atan2(dy, dx) + rotation * DEGREES_TO_RADIANS;\n\n      return [\n        center[0] + Math.cos(angle) * distance,\n        center[1] + Math.sin(angle) * distance,\n      ];\n    }),\n  ];\n}\n\nfunction getLatLonBox(node: Element): BoxGeometry | null {\n  const latLonBox = get1(node, \"LatLonBox\");\n\n  if (latLonBox) {\n    const north = num1(latLonBox, \"north\");\n    const west = num1(latLonBox, \"west\");\n    const east = num1(latLonBox, \"east\");\n    const south = num1(latLonBox, \"south\");\n    const rotation = num1(latLonBox, \"rotation\");\n\n    if (\n      typeof north === \"number\" &&\n      typeof south === \"number\" &&\n      typeof west === \"number\" &&\n      typeof east === \"number\"\n    ) {\n      const bbox: BBox = [west, south, east, north];\n      let coordinates = [\n        [\n          [west, north], // top left\n          [east, north], // top right\n          [east, south], // top right\n          [west, south], // bottom left\n          [west, north], // top left (again)\n        ],\n      ];\n      if (typeof rotation === \"number\") {\n        coordinates = rotateBox(bbox, coordinates, rotation);\n      }\n      return {\n        bbox,\n        geometry: {\n          type: \"Polygon\",\n          coordinates,\n        },\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function getGroundOverlay(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Polygon | null> | null {\n  const box = getGroundOverlayBox(node);\n\n  const geometry = box?.geometry || null;\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Polygon | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      /**\n       * Related to\n       * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46\n       */\n      { \"@geometry-type\": \"groundoverlay\" },\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractIconHref(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node)\n    ),\n  };\n\n  if (box?.bbox) {\n    feature.bbox = box.bbox;\n  }\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n","import { extractStyle } from \"./kml/extractStyle\";\nimport { getPlacemark } from \"./kml/placemark\";\nimport { getGroundOverlay } from \"./kml/ground_overlay\";\nimport { FeatureCollection, Geometry } from \"geojson\";\nimport {\n  $,\n  StyleMap,\n  P,\n  F,\n  val1,\n  nodeVal,\n  isElement,\n  normalizeId,\n} from \"./shared\";\nimport { Schema, typeConverters } from \"./kml/shared\";\n\n/**\n * Options to customize KML output.\n *\n * The only option currently\n * is `skipNullGeometry`. Both the KML and GeoJSON formats support\n * the idea of features that don't have geometries: in KML,\n * this is a Placemark without a Point, etc element, and in GeoJSON\n * it's a geometry member with a value of `null`.\n *\n * toGeoJSON, by default, translates null geometries in KML to\n * null geometries in GeoJSON. For systems that use GeoJSON but\n * don't support null geometries, you can specify `skipNullGeometry`\n * to omit these features entirely and only include\n * features that have a geometry defined.\n */\nexport interface KMLOptions {\n  skipNullGeometry?: boolean;\n}\n\n/**\n * A folder including metadata. Folders\n * may contain other folders or features,\n * or nothing at all.\n */\nexport interface Folder {\n  type: \"folder\";\n  /**\n   * Standard values:\n   *\n   * * \"name\",\n   * * \"visibility\",\n   * * \"open\",\n   * * \"address\",\n   * * \"description\",\n   * * \"phoneNumber\",\n   * * \"visibility\",\n   */\n  meta: {\n    [key: string]: unknown;\n  };\n  children: Array<Folder | F>;\n}\n\n/**\n * A nested folder structure, represented\n * as a tree with folders and features.\n */\nexport interface Root {\n  type: \"root\";\n  children: Array<Folder | F>;\n}\n\ntype TreeContainer = Root | Folder;\n\nfunction getStyleId(style: Element) {\n  let id = style.getAttribute(\"id\");\n  const parentNode = style.parentNode;\n  if (\n    !id &&\n    isElement(parentNode) &&\n    parentNode.localName === \"CascadingStyle\"\n  ) {\n    id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n  }\n  return normalizeId(id || \"\");\n}\n\nfunction buildStyleMap(node: Document): StyleMap {\n  const styleMap: StyleMap = {};\n  for (const style of $(node, \"Style\")) {\n    styleMap[getStyleId(style)] = extractStyle(style);\n  }\n  for (const map of $(node, \"StyleMap\")) {\n    const id = normalizeId(map.getAttribute(\"id\") || \"\");\n    val1(map, \"styleUrl\", (styleUrl) => {\n      styleUrl = normalizeId(styleUrl);\n      if (styleMap[styleUrl]) {\n        styleMap[id] = styleMap[styleUrl];\n      }\n    });\n  }\n  return styleMap;\n}\n\nfunction buildSchema(node: Document): Schema {\n  const schema: Schema = {};\n  for (const field of $(node, \"SimpleField\")) {\n    schema[field.getAttribute(\"name\") || \"\"] =\n      typeConverters[field.getAttribute(\"type\") || \"\"] ||\n      typeConverters[\"string\"];\n  }\n  return schema;\n}\n\nconst FOLDER_PROPS = [\n  \"name\",\n  \"visibility\",\n  \"open\",\n  \"address\",\n  \"description\",\n  \"phoneNumber\",\n  \"visibility\",\n] as const;\n\nfunction getFolder(node: Element): Folder {\n  const meta: P = {};\n\n  for (const child of Array.from(node.childNodes)) {\n    if (isElement(child) && FOLDER_PROPS.includes(child.tagName as any)) {\n      meta[child.tagName] = nodeVal(child);\n    }\n  }\n\n  return {\n    type: \"folder\",\n    meta,\n    children: [],\n  };\n}\n\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n *\n * ### GroundOverlay\n *\n * GroundOverlay elements are converted into\n * `Feature` objects with `Polygon` geometries,\n * a property like:\n *\n * ```json\n * {\n *   \"@geometry-type\": \"groundoverlay\"\n * }\n * ```\n *\n * And the ground overlay's image URL in the `href`\n * property. Ground overlays will need to be displayed\n * with a separate method to other features, depending\n * on which map framework you're using.\n */\nexport function kmlWithFolders(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Root {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = [];\n  const tree: Root = { type: \"root\", children: [] };\n\n  function traverse(\n    node: Document | ChildNode | Element,\n    pointer: TreeContainer,\n    options: KMLOptions\n  ) {\n    if (isElement(node)) {\n      switch (node.tagName) {\n        case \"GroundOverlay\": {\n          placemarks.push(node);\n          const placemark = getGroundOverlay(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Placemark\": {\n          placemarks.push(node);\n          const placemark = getPlacemark(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Folder\": {\n          const folder = getFolder(node);\n          pointer.children.push(folder);\n          pointer = folder;\n          break;\n        }\n      }\n    }\n\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        traverse(node.childNodes[i], pointer, options);\n      }\n    }\n  }\n\n  traverse(node, tree, options);\n\n  return tree;\n}\n\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* kmlGen(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Generator<F> {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n  for (const placemark of $(node, \"Placemark\")) {\n    const feature = getPlacemark(placemark, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n  for (const groundOverlay of $(node, \"GroundOverlay\")) {\n    const feature = getGroundOverlay(groundOverlay, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nexport function kml(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): FeatureCollection<Geometry | null> {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(node, options)),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}